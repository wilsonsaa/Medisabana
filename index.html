<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Bienvenido al sistema de gestión de Medisabana Ips</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #d80f82;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #d80f82;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #19939b;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Bienvenido al sistema de gestión de Medisabana Ips</p>
                        <p>Introduce la contraseña proporcionada por el administrador o Equipo tecnico </p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f24c87841e1f16a04dbe64e6be7c68a590ab21d25a9983c0b8ed6a145a359f68c61bdc4d64c8b1cfd3c48cb43c615acf818e9928c34236b1abf166ba280e3625aa234dd2bcad6dfc35974ecf18f70f85bd4d9d86cce4d3e835634e4032ebe583724591570dd45244b98f8ec980250fb7d19b7e421006fb7c362e1e4b48e47e72b134f2bd36701868d9f0ddb99fec433ae722a260efd73dc4ba4eb1d9ff51f644a5b4776cc1f953cb364f0de68217ea50f9d4de1bce57d7d67e21afdc624c3653b493a32edeea1ffd499a8118327f9952adaa91e600628814dde89910de621b2bb5c80359c08352b19732fbd7334cd9cee7772c3140c98f58c139596e7bc147551e9fb1a66a7f18e748f015a85218f55639097b32b19aa9c4ea87529bd1c46d5f8d7676e9bd8d9395e2a5ccbca550c9be9e5f8e0f8bac1b3b93142ac6e1909df29a85280f28c56a62757c11c832778c0662cd53a71e85758799a4a8b5f096e913327c47e4913d64db21cb0c8ba528fd020168bd6f8c190a1073138deacb4693f54838e59a78685877dcd0ce7825eb6b240bb665ad857efd748641577f139eb0b1b3178392adb2ca4fb8698040fb353bea6f3a375ef4c66329371bf8cee9a1d2f1ff0621311de8eedd0889eabc92a75598256d4c936f92ee29997d0902a6fc158fd655bc543082aaec4190f2e6f04c468afb3396f341ed5deef4c6b98307e8748b0089066c97e77fe88c80e5a4a786f8b9256cd5f245b5abce8677dca1378453785ccbd56660cec6250542449900db3ab67a21172db41f9919aea7e91b511b3f3e447deafa1a36865cc7e26f2bdda06c6e57c15aada826689284269d856e151decd742f267282a5169d33ab18caa26dede41485e60bbeaf96c92aaeefc37b3b6ea92399a3641fa1838a225a99c133db5a0c276e0355e3174a627f8cd37121b23c01c8ee00b87563ecc2c356bc3f69aefb0d414c1c60b4615e26123fc4d8286a4ce81e922041231766f935748467f6c13d04e4ddee2bc49ddfe9689ec542e70f95405d53c1af2d45076894a8672eddee43ad51beeadaa3a3136be7122a40ec91ef3b14d98523fae41f78b1ed59c6a06746dc8ee9f991534e6f1ac26d5e8aca1c2d9a09179d94bbc6675bb464e6a9986a25f7f90879fd12b98e72e97ce293a032e1ab080926ae8f25de66049a4d1c5641abfdfb50866089c517f669dbf467ce88ffe0b80d440cdffef760045deb13ca1f72160da6083ac34064936d22c13b0639ce28decf0ed97252b5c22715b582176c92f16a767acd7abe39f2f4f508e038cd42d5ec1da999649b3cbb2f8049083456a43bb523dc3a2942494b3939e002b595617d18654a27199aba4706a5e62a2cd52f83338f18f684930fa70ac8cfdae722da4fe76ffbfdee5987cb540bf003cf1c36a806a126e0a4da98c1bbb5cb50729070c21e9bfb3f21484377b35daed1e51602bce44f8d97a4cdcd8ba734d477b06f87f981a9c0965008bc74f030930837cf43328c28d0cf80f0060eb06fe6d8ad085377d349955993efeee4be2f0ff2bab3fed3d87bdf0f90fee79281fcea58950e78545be6e72389040087c70bca1a325519c5306825b7a03f1c7fb9a021cd810a4a09df05adabbb63ece37a02ebedefe935766334304248106469782d462f26b24092b0d3f2e227008958ddb14e096ef40391e26b0317323cdbedc9e6eec08aab8d06cae5c4d2beb8337d2282766fdfc96b8f34621a8f1582670cbf6bef30e178f7018401cbc125b1548e6c3d034408721e6794b567c50b19c7014a95a60eb113ba2b219005e7d5196ca4f3a9ceaff5334603146a995923d9eae89a18b618494d428639a77d98023b61dfa7ac36160e5b343dc505450d4739d90b29f2fd10210f1d854bf625507316d6fc9e5006b5dbd415eb3a40425e63a1002fef46c1cf8010411e2c7b33934528ecc48341f74bf48d96cb346a6d39306dd13adf22c4ce7030b79bfd3fe419345964e6f8dfcef32a7d0870ea5fd5935736548dd3e68ee82efd8c13ae5053c934307e0e8bfc452b705e444e770bce7e8f978b67fc3edce636addec72e7b44fb3fb374214f16926db0d9c8a7c974db75b5b0d884a160cf5c78875653dc8480d95286c629ae997b9add2f86273f8543bb9f25e12db3d3fa9d05314fd8e3f7d2d12dc9ea90bff96d626dcb63472c5457e6ab23f0eebff0f728e7b2d1ad520275ab4d30a85927aacd646572afdaa77d90c9ab39b665d7dede44e7c30a0cbd02e6516cc9173d3f6a64542efdcd82167fb88c601001858044c7dceca6804659eaee0f638b5787acc3da6c8a2b8fa1db1f25e4355576a65710e5dd56255a8e1b66c601b8892eb491b0a15b8ded5771cad2aef0b5af00b7b01c5581db5f73e758676e0df23cc11b1e204497464b5bfaff27ee0e596dacbbd8742d8b5d9d797e91ee02d1d98f34e9409c9c28cb6413511d1b32349812ab23fd62487a74b5c6ad0996a1a0e7eb611c61418777b3b41a8b37da5b46aaaf2bd79e84b85d8509df886324e244bd0626a3727bf6cf80183cf93212ecd12463d4b1c20aa11fe25719ee43a4753f852f6233e317d8fa1a742853d7c1bd355fc637a4c3be98374bb62af1e6ae34a1cc5be238f5a60a7a3c591e1d7dce7707b80b4d2fd482d4e86eac154db7f85c7cc101b2236998b2061661bb92306ce33120f79c020ddb6dbb86d1a43e16e1434296d13d70b28fccf6f65ca07059ad38bbf59d5eee64cfd4439035358a34aaa39580b9eb6e9d015790e5431462d730a5bce52748370cfdabbce4ed21bb8185f103ab53b3e6c64e636606e4ba246aff1ab76e8d81cf784505adeb5d927a1beacc87f53c33357811d96965fb22432478836a51bc5a9d4a80c43a9c8292a98eb3dc82856e15ae545dd4742bd81b9cdbe49ed25364ab8390d8fe4e612596d59359e992aacfe498df69e36bb72d6bf57273cb51e54cf96c82da415d38c31e590fd17d84de0b6f395f8ed52e5ab0a056af5880a33a0e0014a1b15c20c213a29822f8b0361fbf2a52bf87097464e3f455941201a2329486c13a7b99a6b61439403b997306326d14d837bdaa9ad6f30f3f3edb805ab1bb9f83f6c77c3266ef22b9d154de9c528f482c9895dd6a2ed8db8c33ae82241398e88569ab4697348a50e84e15742eb5ac118c0ae95443830dbaef40a13ce2c0a7eb50d9826560d2f96e8b2be47508d450cbc4c525cc0935db056019859cf6db1ce33e77634a3a322085146d5bbffcda19d6426c2c63d49086cc4a3e19a283ad19fb781d3537dcf1a758f6d4cb7f91649d266f77baae7dd7517cdfbe73423632a71e07736837c23cc0ae13b7a0f51dcddc084893ed64258667b0a9498b4ae339a20c582e8736203835b03445c7b317429dc44dd4301c9572c07e77bdc8e5bfc6974049bc61a95f908f4ea40a5a01ec2ecd5006068fe8410bae38b26046a08259b03126faf5542ea11aaa8be07963d61d2e7431e7817af20588079f11633ff7ae1ffa3c53181a89089756b641d17f0514dc91e249481d3bb6b45c988d1658797d3c698548c876dfe0f0180c6730ab8525c81c6ba01a7f990f122431ddb8ebd20897c517927cae1e2513423e2fd5184996c10e285a4eb1943daf2cbe940ea6c37bebb86bd946bd4d3f5f0d8189748cd62836999f322f520239a265516cf261ccfbcfdde57de1da449a44c2c855b43f9706b7b9309134375798dc7a20b6c7edee562e5ffba465abf852af70afb1bdb1b7d696187e86e8c6c4585a744f1b6fa1571c03068c86f66f87227ece38bcead26cb66cc2659cc540b4af226b837d651ad7138aeb48f1ff6027b23c9422b2b9da13c5608d4ec6f5432ac7de3b3c1704235e8032929ad25e53fdd49619834b5557791bb749d6659f69d16bd7136c9277037034448e7d7bb03fa787f0ba13b900cc4ad569b6e713cd54f6c25591df9f4290aec63cd86fbddcb79b92799b5fd29fd8d7a9695e9f0ceae6e4979d718a3269eed45e08bd3c7e299c4b63925ec0dd778ec7599653e9c9ccd62bd2cff6453cbee3bb28d1b7c9ae1e8a83b9e381d249364be44470bf0d0d8564395ee61d9ffd91de3010292bef183c4a4b5fc38594dd14325ad9945bd9d61317d4764540991475dad81ab5f279052f6d6066c2fdf235cfd60c258eaf6d18fe917a54dfff0937c25ce2dc10cc4e602249c8b0d99798cb2eeb5b1f4475fcf321ff8ad0be9596bc13c308296f90914f0114dfb5a6b5197cdd228e06bfc144d560f52be2be6ea32fa616b9a90aef6ae403e48b9702c0c84b89da60d957782ee6e16f1d385e1e1d50fc2919cf482fd79601f4c904ca7bc2fc9572f4f8a808189345decad92272dcf9d29b86d1ead8a61ccb32a01024ca2211502a9c41cee7533bc52d46240e0cf1b9744081aa691214c23f953b29e0e7d785cc58bbad7b7d940aa83a002232c1ad00001704308cb8145bf6614b4200b535d5095c323e8e94ad513d5aa1c8e3cffe59e4222c6498fa34474f087d340db3a5b17e28ed4fcd9af73a6538e7a0ba094e8b384adb36127b0712cc92ff5d6d215a17684dd10bb981305b19210a494e9b4819eaa15fb36a807262ebbd9cd42bc38695ad532c66ebe8a394280a3db2dae544f1851ed7f57953cc439480f411c0938425962bbc700367c1a69bcd0d29182869b91153f3f0c6f4ef0893d51e465a03930fe76bf19926b509fc28d7ec8aa97abf44a0d38b25fe750ae738fbcbb52fe889975742d1308f5061b34d6298a1c85d1fcd56bed13b24a2fe74086dee5be55f48ef6e8290e30a8988c88614ed07495be558feec9f21ff64d6558f121f25c9031f66f4f1d3ced18a7435dfc2e4478e7b379801004c505ca4808119eff63bb3b81faa2e58b9a7a26bee8d58e855e38030536132ea8c44fa480f42d497dfb17df6a1e70f1c1fb0815f0e74fa618812415389de103c34c70417d6e31bbb327e5c173dcac244226ad2164053a6ca2dd7bf78cdddc1ea0e4cd7a6c815b73eede2986b64abf010bc2e4ee4b13d7d1cf56b086f9880d7c42ea0a66ed7f68cbf0b1d83c4e762fba300447bb2501a786077abff318adc8a94367c9c9048075400a65850fb44ef004023b141b5a51ee2368b36560c4e42f7ed007c71c374eef20616aec600fabfd7b25708eb314056494c5f0ba1009308f7f052c1a1582632ddf3a02936997393ff9415867354efcf1e605f95eedf193788c11a30289c4752ca8e3d9c45ed92a26c789d534412f2f42c61781fb30e87dec77207528e341c44a7f6cdf146285f9005fbdefb7a68d3f8a6696359cd13d4e8a6fbc8606d1fb91a2af2e054bbac7e7624a94e870eb9b81c81af6bb5f1a86f72e418d42290e00a584c43eb55f8a84c4e8f19c805c0c737951acde80f685ab34072b5eae5ed8a69ca867400821750bfa9ca97a3a3d4cb92d6a5e137a13adb5d962cc68ba65b7c346554e7314ba80d5efcd2eed86f4a5f23a01259f1d9d1b073834c917df5ca291a9886634d3cf701e792b749032e037e8df7e7178f974885b15f91025a1277e996b082a6ecca4c179450d49a8d0e8ba80d68ff91f702b38616a8ebe23755108a12043c684c8d497b598b0b68e551c232a27601dd7826e6f7bb4c18eca8db4d7b10be5950aa62a677ca510c00d415bce1a65ba51daaed135a7b7fc0732cfa96e56aca1ae2a72e53e82152a127dd243d7c9ad412c914f38bce09dadeb19edb3be9b15d9fb3bc5865af745a530b21b5a59644942f5168959cd00d1f8d7ad01c5d4b58ecfe53d33ff6e481e80dcd3ee21e211656395f55f7994188714c08f35ffd69b46571c791bdc53c6f00d161614a35b96d26a2a3c33f7d55f58c532c04d5610b575813114e4ef1bbdac9b31749728e8c96fdf81aa531333afb8e64b8d11953be3fc6d0d6b6fbcf9403fc1f78ed74d254683a47ddbe2d466fad164140fa2f60f38c8eaf1ca9be2f9d3cff36d85a3187c7ee5fd01e1eb2bf189e4a189ed01b1312b9b49336349eabde96a1c92c85792352fab8ed1e63a0edbfc714f01a90a23c2e2aa4ad06ba95365156129a61317c69c2dee7bf742f0359907154aeb7e571bbd5e8e38e096fc9605b319ec5e1b13332a826be6014fe26fe924f9377b47cc734ffbe79f4b9e1043b2b521ab8026a28f37965a6ef64c54e4236881ad3e70ea3816d61878734fe198cd5a0c5e5c064302bce1347c040f6232801c2cd582903830841ff6fc9956a782669cd7f3f2af5e83078dbc1093b15867931f7b38e4dfddf28923e0a604dcbd824d889624089e815e30fc87429149570a3c5613f3e0af67acbb1531c6f604b6fe049512bd90e8a2cea76e01f2a9bec4393bc4cf40cc46aa50dde40750343dcf091e6f435a984a4362e90072a4f8c0da71a59a51ac9dabd5c3c342b87b8a417b667e07fcae85c2b83cff2c55a5f7647690e3a981494f6bb1439f8708196539f4266b05b71a8d7dedbeb2423d9e361acc971c890452fe66ef067d9f28941168f119203707ed664ff30d82044625703b9c8890f48cd8e3abe04b690c00a77e46235aac69c35717b07ee0d9a1b88d7ba5dccece67c77d14c13a00cc95c731756e5c2042a1dc363c0c10cd130859ac80105c0ce92ba913570a3faf1a420f452207defc321d4f09269c87ef2271f7ca33cef2dccfcfbeb83de9606d056d54b2a27ed73a04a4e9ca1b096681feab77bad2458a5e676edcb763d34051e72ca2481ffedcc50bebc82dcf355cd6282f09bbb3b13bcedab976ab90c9383c01e84e92007171854293034370b3ba8f3bb1faca586d5d9e1781f1a4dee009e1aee319884aef9465923b19c638ea4c6e695391ba7b35061c1ef6d61c3d0421f1e062a9e3f9c82452071fd592b0d810e83d250adcd2f4b5e5b41e71eb1bbda92c686519ec65c5e64cdd7bda7a3313a183213bd9aba8bda86920008b34ae187c9f4a5c6955b3cedf4fab1eb145d2f51c72aeeacb49f76892d7e6e15da6580ca14e78e4eeaa1cb244aa8c52bc69e8d7324643955974e16077d282875e68e538a59f1ee84f4dd69c5eedb8dc71a068db82b85085e4208dd09701d0bdb05f85f64f3bba35a9f31f9d5ae930396217e0fe741f14620bee345105548804c7ee9fb4be06d657414b725b0f8aed73c88c6bb4d97782b5c6922cc43ebab87cd2fe8c330e379a725a1c74f43f3896d4dd80a3c0d6d78df3690bdd3037cc8ec1b2fec4c71c01824239085379f9e42359276c76451de3e3c5f382fc3d8b89fe8a64c6e5f9a5c5810d5313d202bcf621d114646031e0f18438f656af0c3fbfad44bcc8e33edc3993352ac692705f61494f4862961c4c050264abe7e355bd0e2371ea778e5d94ae16e7d5a1307b828c5e0b8997cf6b280ce873856a3bb5341e871aca052de537cbe45df8877a05afa1860d09cd471ec1966326d7d07f819382f394619c135f2b5c28913e3b331a8b3e2a7987d0a6c3f6491ae389e3f6f26dbe1385f2a86255963072a109c843dc8bfaf7e4035151a5ffa5e3d8e87ba6a5de304b34e0e3a0921c9d86f1ec1eb53a892a0a4953aa4a1168276e053b4d863e9baf67bd1b9e7459682e318f7ab3d9df935ac99cfc6fbb58f798c61970f7411809bd8d634a89ad4d786b1f3e24786bcce8c94bccf34ea17f080c0dc2940a0b6e6d4668d38ab7be1da2bc2154442d0c1f58af39dbf125de81a8a0a85d8330c2ef84076e799e26e38e80188416462297e0d1fc93024b8393d712e6191772a3266dd7d440492a392d97b60dfe45ec62d6f6947638a09025b4e31d1f160d8c610ce9bc737be99cfd7b8632d46e6c927c12f2657975f2b15130ecf59ecb3a23abb82fc9321dfa422c735700297453a162616bbc1aae243638382d8e6ea4a48b8aae68649d093f49cb81ef5d9ee07d58c224f636b3a0ffb695a6c95070cc87b3efdcc5467f599a356569fff85ce0ca7641c68f429efaedadd76ffd6a4605ee77cc0a0b0333161fe689103e3f511805a71b19c6037ac68eded176f51a2cf5426d05380a2011a03c198fa3e93f9f1e13926dfc3a8d7842e0606e8a09778a3583a82662eea619b3e7b4cdadc013e6a86b3e3ae2dcc5fb91abfe095fa722d5d55858e391c1517fdca001413999b8b69794d28a84c263ff5008975e056eebc2059dcffad0f4c9f17306e310d5114c395c90aa8fce262301dc3203d8e9c1011c4cbefddfa50b21cc0518143587ed84b14dcb5bdceb3c1d6d62d934764bbb6995df623597e3c02f4b9007fd6c9d61dfdbc34d39ff088448476c595a31d48a2f1d58db465a33285688d4172a48e7d4728d65463de812815cd6d18bc1e40b982b56265b7c58faf5f1fab647de44f0c3579157b3c8daae72d5dd10b01abb2d25e298e1d8b9a2529cd2e5654ac413d048a8200e46269fbc315fbd46a3dd7414d097e0e7453ef00da1139bd86229444e2da2bc691873b5ea483ef4bfec61aa739eb693e50a1b81fd55abfbc10fa6df8daa9f59367248418879f0b1b788d3e6eddcf7369bbeb15c823752f33bca6dad6edc323bddd829b946c496cba6de08cee6ee3afc32300b925536b676c63988029d344571f87a91106308c661aadec115b88c2ec4ce8498ce0a983d8979daf331f7e06b827af4cfdc80c6d097ac57a3d36dbf6bc7c211fae09ccb75d73e2bf31d932512d69495c0be539b1d859324c5f20e6ad68810fef0b1dbd6499440457b641d5d8135bc68fdd183a7a86c23832520e27de4680a65675584aa15f6edd877f5c737eaf9f387583636e80afedea323fb80bd9270405e2ea25c2e97c86012ba9ae8dea0e7b0809e3b2e880975c7e221b7a731d8353356c9146ec867f8a6ba6f4b2e2fe31374f0ee70c0c929565bbddfa4dfcff91c1b7ace00a9beefc5d21c03b01dbd10f91473145363c8bb1bb589826e486d7d37fd44da9ffe7cd84178c6277d3d1103d1a868c8cd07923311d3bee617a87250e02084f5730e9b24791d2c03ce4c7eb9bd1658b31c94d2e2e39c0f69091be4be4b81974098921951e4da98a5de53e8209c7bf85b955e755c654978f87fce68473e434f9f97ad6cc06a67a95e575a090258561be99d783aac67f91642195b5b45cc26dfb7699ebf3f5d6349ba910b4b267cdd9ce80ab04b185ade46b11f30c7883c68cabd837353bbe360664929fdb2bbc66926f74de94c12fa2e35595d5428a28f29a4d5e977e29a35d08684040363ac0243c5fcc7df265c3b2d943ff46da67baabc32db3c20eb892b27c9dbde4165e0c466b67488b812945d7fbd84140f91257d664f0fa2d31d7975779f151694fa42af3a3bfd2dc13ae05a3e5b6f521e9734523d5d9596034211a96984ae36edb5193de5ef043741ecbc494c446e913ee3bf215c18dac4728d9af03d46b8e32f67ca49204847b1134a31943181852dc0db75ec3666800e7ff19cb54c683b49f90db771abfdd74bd287d28808bb7991a9649f82d9af91756f0088ad1cdd25da93e175ec4562cf0cf692312cbf8c4485e5427a2e1063bcb6d8ae0121f168c37970f158639c6eb6f276aed9fe997f3671c418fae83c8e01851105d6e0060ff7ffa78dc139349bf8a4bcfa9371c84b9b100bc42c4e93bf74f7c77c4fcb3d29aa34973a1a1bdd66a37cbb701f4de8ca3d40ea103ae61e70107b516674ee1b483f8e4c544818e94372cde5dfd25470fdeacade85bb58d7aff901ade1032f9b99e580c21157005a15100364aa59afd875f94b1f0a0553cf73b34bfd2cee7615ed62aa71e324d3365d0bde4ca42c5315f5d6f44795a1e8b31b11230bb1b9bbca7b28e876c93804af12970525584d48088570dd3b06a21f0edb30f2b77c74430e601205d478552f0b7cf40ff618946d645787bda1b6d66c36e741a7f0c252ad73d768fea407dbd36c7a87862ccf68491580b0466a738e95fcdf4b5a2701a2cce0e2a193afb4f9aec6e9bce0b5ead6c9407451e688a5e4a8745956e34357972427e212de3d59f8b4c16deaae2e6dab5dfc685de9f7aa2968eadd185f0112269de6d635d25e994c4a3313ce9e79ee5450540080487fadeb000364b627d59f51e5108cc921beed04f9b2d446be62a6407fbc9302d88355d7d153d1da974ff51504b95415b97518bd8ae5d662d1fe06e2801b69bff334e1a1bfa62c9ec02f09b919ae1260b1f27faf88cdb1aa43566d8833b77e778f5f10286d224049c02e2a1118f72a51aa2944b7aee5ce5cbe8cee7c29b54713bbaf12e0a6b2388345cfeb1a7850024f45c6356e78f2a929c2ab155fc7e94ab734b7b52add0e57c76dc0a8251141f4560788639fe8e9c85314fea8e9898efc827b1c23be12bef310aedc6e99e5395a5e77bb9633af03cb339542490c0e88360d7c3db75dac800c2e346d8d8081fed2531db9ab7d5f60fb5c1aeffac48f31d4992ac241998c882cd792d4375a11531d34e9e7e8a5f9d06460bfc392c015aa443c0c6ea2e736ac3eccc0831d554c89fd6354aefa1b4117a41797581b2f1931861d623dd2a6ea26b3550666a71549d5c3cbb47f6f8b6c2df1b272bd088108b6b4333b623274f4cbe98d3cf21493635b81e87bd129f9fcc90f19c2cf9952c4a700eeab879c2d4f8034b1b50d82e6d49da4665c706beb0f1144f5580be5344bb4b44c1f139b5feb4a564e46b0a1f2208f9ebfb281ded450d6379ba5ae15958fe029abd2710c72d05c32592d71134d02f6e5bcc130160700cc18867de00b89bacea4a0022c882bc5b56285f26c2c2f8b5ecb4c7279686352750c946cd781db618615365f1d54d867319dc75667dc41db0ca5c7e3364eb2dab71292e334d8de3aeaf08003ff2b1d6b2cf479e182ccdf5bd195b916efd6c29cbd43ba48c08e668dca015523dfa634c65df719bdea723211ae436b20a68bf1bd2612bcf4499c0c50de3b5530940345ecc3fa1bdc481b83ab127ad88aeb57f80a7597723394195c7f1a20c58c33d5e9fcfe0b21e01f2b36bd40b71a9fe30ece14b31a75aa0cb4718bf4d3163a2fd7c0155eef74f5a38db0d3a82c9d62e3e831d0a282b42c17a3900bf5d53dc3d5c8f278c3b345e729e94293307d19c1470aea005418a1c1973777f5772beef39dc92cadc62127b40ca8f8dc20613d6d33a692c0607fe0e455bf36649efc664540925c22b4b59b09766bf09d47910a8f8eb3250bf63cbf230778aa1e0931e9ef0b0fc83fb5b6043374582dab8829dd4a1ea37f36a7608f638c2d7fc13ed6321f68c54a9b080fb2d4f06588a92fcdabf13b01d6959c7a0311562c78925508b2a3be29bd803ace2678578e27416eaa6d340e2a44de7d314cdfcb048af9861bf6c98f16fa7fb7bf2fd4bab6c845c680c50714457ebe2b21cea31078edf413521990c30ab4fb3d231cbc6a27b8489a63c7545cdb83e6cec827943befc17319bc6f6bdc6b2f5378c957063e7da1af9af83ec8492471ab2618ec7761bbda285928b7feff80edd9a78570b1969706dd79487e3bab0baa5b8e61f7b588eb7a75596df2ce0cb17b786aaeec2e7926e61de3701943838f4da91fdf7f65ab15de63b325223d3cfe90b3ce31db0b8358ade12ef008f440bc185319347b02c4a0cb7cd34739db802d6a3051c0b9a7f56e8c8c24010c3d3687923b98cc35783936cee5cb11c28c6891fc5a81c32b73cadcae77ee83f182c7315d48fd32bceb177add63af4170c509fa3418f9c4da0bcb232c302defae7ccbd886d543d8f6f212a47016f779f5855329943acc745c6ef8325f6f56f451902eaa92a79f926f0a41717b77ea2ba44b9af1bffe67999658d4fa28574685ed252d892d362a418251e286a5041ade87f60a58f04fca68fa8ce6801961b478b2b8b97bee0819eaf7eac4eec0f210d663f54b583d71a0cd5dcf07110386476165676ef40f5e356cb3e99c1eb6261957fd65a089e06be1846fa8bc0369a15cf83e6c803678acc1c2aaf18f9c75348d76c41055f6a96539220fc3a3b98b0de95264fcc4d6cce8b6a745eb74029257ec7f6fc943518d2461739dfb55b75f321715aa9c90f6dae85ff6feb7abc1a6cef3e718d31f1851e33e8ac963b292114cc27beffd7ec504fa75e60263a189e4ac43bf4584185f6da41806aa498a57365bd0f4abe1d0faaf836bd356a9242e57fa6627cdc40e6a31048915b439e678dceb0f958be36ccd7ed53fb15fc044fa3523906a6b0d1bd243b1eaee731f6b26cbd554f8e0589bfae4ac2bb2efc07dbe761c357cf8a2279cb3830e6b118e556cca3dbade90fe481ece7189eb11c6fc5f6ce487c010b3e54abf441fe602d3a7b1cfa73e1ca7b8ca8947a24b9827dfe2fb523fe88bd5e24acf6979bdc8fe127b16fdaf434026137666f9a46ec5983754bb3b0bc86a0904a19a28e388ba462a1b729801ab5487c6be6d31b7f1c4d0982aea189c259531a37f0c9674e908bc8b70259ba67da7c9a0e090176009bf50f84c311ab4b2ab53bdcdc001628b58368b22841c8cb15b77bea2507230c23ca87e05cf192e7642ac896b4b4e475268f46caaa4f2b3d2f4a944170e240e197b42b5d2015a597d6ada579be91c6ecee99bf97108e385a287da6ad0209d2f6c07b99d7f16c85e58fe280fe7d45bb11a7840673e2753815101d632d96d6c69538dcaf49e0e116b8ef51fc8fbf2acd923a85aff04d7e010bf9bbb5b2e21f9ef12ce6835a456bee7f2bab309b979f10e30fd905f201c731bbf0e7481cd4924ff1975ca822df39f36f71ba8c9291b45072ac81224470fa3422a242179a7fb3fcaef57f81a2a9dd6cc08499fe15c78ef9d16a7bda9a2edc5bdd4f81c8cfd5065038e0511b781ab690811eb86752134573c64e37b4c1f4d3da8d0c125741c1e02022fb0b88b2393b8287c2cc4bc3b5ab1d5457d7e6024bd5d849113143d0bd9259f3668d0da6d4f7538f32532674f0fe294986de53c16d7c29cc1a5eedc2f411516c7f3fffcd6329e3b77be9601a2e66a8c24d667b43be1c4d2c387dd0ea40b70d81e6747f56695cb9d92d55330d1cd6e811549198f6a35d3e0386832a7874bd00500cd259f85c113c2d10fa48cd0b85a05143d37908db172df90f7e60dae5d3920e85c738fb0f6c422a13e686b6a2d67d6a35f625ffe000c4f4063d29979fdd5c3464ef36dac74ba5ed14896aea67c20eb970bf6125bd3cb59f2f2d3577bcac6de01e5234c913cf4c6fe8720d3bc9db20f312464c178f3b6744c1cca8eb21a6e388df386fe4047466939ab8ac2c2b5467db3e80f379935a6df442e68ef418c2dd893f59959a8f23769a2a5fe5a76a263f4deccadc06f2f48798861927f50f38b158b33b3f9cb1eb1d8fe2eea7e3784062b8d8bb5d054befd1fc898e45a8c3d991fac4cbf527c5f66a584dce9fafdfe42d621a3f51b90c1d8e4b4d6d528aacb9ee68dd667576ff18dbe25f492a62adbb271d25c7f60e7268513160f817e56d2a538383f31fa956d97c51ba36d1372bcd12b2ca26f6e5466eb32838ada4efe69e5593b6e05e5d44bc1478770338838ae90b4875a2382c6dc2ec9b4be648bf908de4025ddb7ec0541464f0ea3c9091ce06c80f2bab8d1ca8df9c0eb07a3d9acb4d3d08ab59e7db9c3d72446ada4874603f2a0536ce2cf085bb6797956c82a38afa6242218544f18f7e1f289295fc208f501d47f1a6977e6ab811dfd130d35a7edc5ffa07052f5e817a61f94225b01bfdfaf07ef9c0a79425e2941889780ec40c9e3b7125686865250d3067e19d74e6648d0e031cb6cc22938ed722c005ffa4672bd4abd0f93904da8e758333963b422c09e4375c1e8d8e950e7324eddd662765e7ed5a7eb85a10a218a23f5124503819a480258b4958e33f910e059ac15616053176cd7e512e600f4e6531cdeb6caeaae7c8803efeb00d985c3873e82a7ec4ebc9fd0cf5469a1946e517b21c1b5ec387fd0ac22a1a02d5cff8f09f6e331efad11edd0be1253b1f46450705ed3223c159ef26b82472f5a9f8b85dd9d83beb903c457665a3103952ec040bcd33716ca30e8e6dfcd29d35e2f19c1fe9e422aedc29e48d8b2ec14965381e9fa4356ed44328e95bc510e94a5fc220d3e85c5251265bba26d7b1cb9d1b0971f95e8da4e1ba487afff2122f8c286372c9488cf5c7cf52ad1cb202e93a08225927607e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"27c159d29461e0fc865d06261e457359"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9cd1f6444b0ecc79',t:'MTc3MDk2MDkyMg=='};var a=document.createElement('script');a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
